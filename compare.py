import timeit  # Імпортуємо модуль для точного вимірювання часу виконання невеликих фрагментів коду.

from typing import Callable, List, Tuple, Dict  # Імпортуємо підказки типів для зручності читання/перевірки коду.
from bm import boyer_moore_search  # Імпортуємо реалізацію пошуку Бойєра–Мура.
from kmp import kmp_search         # Імпортуємо реалізацію пошуку Кнута–Морріса–Пратта (KMP).
from rk import rabin_karp_search   # Імпортуємо реалізацію пошуку Рабіна–Карпа.

# Поріг класифікації "коротка/довга" за часом одного запуску ====================================
# Поріг класифікації "коротка/довга" — це умовна межа, яка визначає, наскільки швидко виконується 
# один запуск алгоритму пошуку.
# Якщо час одного запуску менший за цей поріг (наприклад, 0.05 с = 50 мс), такий пошук 
# вважають "коротким" — він виконується дуже швидко - для надійності потрібно запускати 
# багато разів, щоб отримати стабільний середній час.
# Час довший за поріг - пошук називають "довгим" — кожен запуск займає 
# достатньо часу, тож один або кілька повторів дадуть точне вимірювання.
# Ця класифікація потрібна для автоматичного вибору адекватної кількості повторів: 
# для коротких функцій збільшуємо number, для довгих — залишаємо мінімум, 
# Фактично це спосіб балансувати між точністю вимірювання та швидкістю виконання бенчмарку. 
# =================================================================================================
CLASSIFY_THRESHOLD = 0.05  # 50 мс: все, що швидше за 0.05 с на один запуск — "коротка", інакше — "довга".


def read_file(filename: str) -> str:
    with open(filename, 'r', encoding='cp1251') as f:  # Відкриваємо файл у режимі читання з кодуванням cp1251.
        return f.read()  # Зчитуємо увесь текст файлу та повертаємо як рядок.
# ==========================================================================================================
# АДАПТИВНИЙ бенчмарк — спосіб вимірювання часу виконання функції, де кількість запусків (number) 
# підбирається автоматично на основі швидкості самої функції. Його головна ідея: 
# якщо функція дуже швидка, робити багато запусків поспіль, щоб отримати сумарний час, 
# достатній для точного вимірювання; якщо функція повільна, обмежитися мінімальною 
# кількістю запусків, щоб не витрачати зайвий час. 
# У нашому випадку: 
# autorange() сам підбирає таке number, щоб сумарний час виконання був відчутним (наприклад, >0.2 с). 
# Потім виконується 5 серій по number запусків кожна (repeat=5). 
# Для стабільності береться медіана часу серії (щоб ігнорувати випадкові “піки” або “провали” через шум ОС). 
# Час одного запуску обчислюється як медіана_серії / number. 
# НЕАДАПТИВНИЙ бенчмарк завжди запускає фіксовану кількість повторів (наприклад, 10), незалежно від швидкості функції.
# Якщо функція швидка — сумарний час занадто малий, похибка велика.
# Якщо функція повільна — вимірювання займає забагато часу. 
# ПЕРЕВАГИ АДАПТИВНОГО ПІДХОДУ:
# – автоматично підбирає адекватну кількість повторів;
# – забезпечує точність для швидких функцій і економить час для повільних;
# – використовує медіану для зменшення впливу випадкових піків і шуму ОС;
# – дає справедливе й стабільне порівняння між алгоритмами.
# ===================================================================================================

def benchmark_adaptive(func: Callable, text_: str, pattern_: str) -> Tuple[float, int, float]:
    """
    Виконує адаптивний бенчмарк:
      1) autorange підбирає number (кількість повторів) для однієї серії;
      2) repeat=5 серій із цим number;
      3) повертає медіану часу одного запуску, обраний number і медіану сумарного часу серії.

    Повертає: (median_time_per_run, chosen_number, median_total_time_for_series)
    """
    timer = timeit.Timer(  # Створюємо таймер, який буде виконувати вказану функцію з заданими глобалами.
        stmt=f"{func.__name__}(text, pattern)",  # Код для виконання: виклик пошукової функції з аргументами.
        setup=f"from __main__ import {func.__name__}",  # Підготовчий код: імпорт функції з головного простору імен.
        globals={'text': text_, 'pattern': pattern_}  # Об'єкти, доступні під час виконання stmt (текст і патерн).
    )

    # 1) Автопідбір кількості повторів у серії
    number, _ = timer.autorange()  # autorange підбирає таке number, щоб сумарний час однієї серії був "помітним".

    # 2) Кілька серій з однаковим number
    repeats = 5  # Кількість серій вимірювань для підвищення стабільності (будемо брати медіану).
    series_times = timer.repeat(repeat=repeats, number=number)  # Повертає список сумарних часів для кожної з 5 серій.

    # 3) Медіана сумарного часу серії
    series_times_sorted = sorted(series_times)  # Сортуємо часи серій зростанням.
    median_total = series_times_sorted[len(series_times_sorted) // 2]  # Беремо середній елемент — медіану.

    # Час одного запуску (медіана/number)
    median_per_run = median_total / number  # Ділимо медіану сумарного часу серії на кількість повторів у серії.
    return median_per_run, number, median_total  # Повертаємо: t на один запуск, підібраний number, медіану сумарного часу.


def classify_run(t_per_run: float) -> str:
    return "коротка" if t_per_run < CLASSIFY_THRESHOLD else "довга"  # Класифікуємо вимір за порогом 50 мс.


def build_table(filename: str, real_pattern: str, fake_pattern: str) -> Tuple[List[Tuple[str, str, float, int, str]], Dict[str, float]]:
    """
    Створює і друкує таблицю результатів для заданого файлу.
    Повертає:
      - rows: список рядків (algo, pattern, t_per_run, number, class)
      - sum_by_algo: словник {algo_name: сума t_per_run по двох патернах}
    """
    text = read_file(filename)  # Зчитуємо весь текст із файла.

    rows: List[Tuple[str, str, float, int, str]] = []  # Список для збереження усіх рядків таблиці (детальних вимірів).
    sum_by_algo: Dict[str, float] = {}  # Агрегатор: сума часів t/запуск по двох патернах для кожного алгоритму.

    def measure_for_pattern(pattern: str):  # Внутрішня функція: виміряти всі алгоритми для одного патерна.
        for func in (boyer_moore_search, kmp_search, rabin_karp_search):  # Проходимо по трьох алгоритмах пошуку.
            t_per_run, number, _ = benchmark_adaptive(func, text, pattern)  # Вимірюємо адаптивно t/запуск і number.
            rows.append((  # Додаємо детальний рядок для таблиці.
                func.__name__,  # Назва алгоритму (ім'я функції).
                pattern,        # Підрядок (патерн), для якого робили вимір.
                t_per_run,      # Медіанний час одного запуску.
                number,         # Скільки повторів autorange підібрав у серії.
                classify_run(t_per_run)  # Класифікація "коротка"/"довга".
            ))
            sum_by_algo[func.__name__] = sum_by_algo.get(func.__name__, 0.0) + t_per_run  # Накопичуємо суму t/запуск.

    # Два патерни: реальний (хіт) і фейковий (міс)
    measure_for_pattern(real_pattern)  # Вимірюємо на підрядку, який існує в тексті.
    measure_for_pattern(fake_pattern)  # Вимірюємо на підрядку, якого немає в тексті.

    # Вивід таблиці
    print(f"\n=== Результати для: {filename} ===")  # Шапка блоку результатів для цього файлу.
    title = f"{'Алгоритм':<22} | {'Підрядок':<30} | {'t/запуск (с)':<12} | {'number':<6} | {'клас'}"  # Заголовок таблиці з вирівнюванням.
    print(title)  # Друкуємо заголовок таблиці.
    print("_" * len(title))  # Риска під заголовком (стільки символів, скільки у заголовку).
    for algo, patt, t_per, num, klass in rows:  # Проходимо всі зібрані рядки вимірювань.
        print(f"{algo:<22} | {patt:<30} | {t_per:<12.6f} | {num:<6} | {klass}")  # Друкуємо вирівняні значення.

    # Підсумкова міні-таблиця по файлу: сума t/запуск по двох патернах
    print("\nСума t/запуск по двох патернах (менше — краще):")  # Пояснювальний підзаголовок.
    subt_title = f"{'Алгоритм':<22} | {'Σ t/запуск (с)':<14}"  # Заголовок підсумкової таблиці з сумами.
    print(subt_title)  # Друк заголовка підсумкової таблиці.
    print("-" * len(subt_title))  # Розділювач для підсумкової таблиці.
    for algo_name, s in sorted(sum_by_algo.items(), key=lambda x: x[1]):  # Сортуємо алгоритми за зростанням сумарного часу.
        print(f"{algo_name:<22} | {s:<14.6f}")  # Друкуємо назву алгоритму та його суму t/запуск.

    return rows, sum_by_algo  # Повертаємо деталізовані рядки і словник сум для подальших висновків.


def fastest_by_sum(sum_by_algo: Dict[str, float]) -> Tuple[str, float]:
    """Повертає (назва_алгоритму, мін_сума) за словником сум."""
    algo_min, val_min = min(sum_by_algo.items(), key=lambda x: x[1])  # Знаходимо пару (алгоритм, сума) з найменшою сумою.
    return algo_min, val_min  # Повертаємо найшвидший алгоритм і його сумарний час.


if __name__ == '__main__':  # Точка входу: цей блок виконається лише при прямому запуску файлу.
    # Таблиця для першого файлу (власні патерни)
    rows1, sums1 = build_table(  # Будуємо таблицю та отримуємо суми по алгоритмах для article01.txt.
        filename='article01.txt',                  # Шлях до першого текстового файлу.
        real_pattern="інтерполяції для пошуку ",   # Реальний підрядок, який є у article01.txt.
        fake_pattern="а я у гай ходила"            # Фейковий підрядок, якого у тексті немає.
    )

    # Таблиця для другого файлу (власні патерни)
    rows2, sums2 = build_table(  # Будуємо таблицю та отримуємо суми по алгоритмах для article02.txt.
        filename='article02.txt',                  # Шлях до другого текстового файлу.
        real_pattern="значну розмірність таких ",  # Реальний підрядок для другого тексту.
        fake_pattern="ходить гарбуз по городу"     # Фейковий підрядок для другого тексту.
    )

    # 1) Найшвидший алгоритм для article01.txt (за сумою t/запуск по двох патернах)
    algo1, time1 = fastest_by_sum(sums1)  # Знаходимо алгоритм із мінімальною сумою t/запуск для першого файлу.

    # 2) Найшвидший алгоритм для article02.txt
    algo2, time2 = fastest_by_sum(sums2)  # Аналогічно — для другого файлу.

    # 3) Найшвидший алгоритм загалом по двох файлах (сума сум)
    sums_all: Dict[str, float] = {}  # Порожній словник для накопичення сум по двох файлах.
    for d in (sums1, sums2):         # Ітеруємо по двох словниках сум (для кожного файлу).
        for k, v in d.items():       # Проходимо по парах (назва алгоритму, сума t/запуск) у кожному словнику.
            sums_all[k] = sums_all.get(k, 0.0) + v  # Додаємо суму з цього файлу до загальної суми для алгоритму k.
    algo_all, time_all = fastest_by_sum(sums_all)   # Визначаємо найшвидший алгоритм за сумами по обох файлах.

    print("\n=== Висновки ===")  # Заголовок блоку з висновками.
    print(f"1) Найшвидший алгоритм для article01.txt: {algo1} (Σ t/запуск: {time1:.6f} с)")  # Висновок №1.
    print(f"2) Найшвидший алгоритм для article02.txt: {algo2} (Σ t/запуск: {time2:.6f} с)")  # Висновок №2.     
    print(f"3) Найшвидший алгоритм загалом (обидва файли): {algo_all} (Σ t/запуск: {time_all:.6f} с)")